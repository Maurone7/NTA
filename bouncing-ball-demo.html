<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bouncing Ball Demo</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            font-family: Arial, sans-serif;
            color: white;
            text-align: center;
            overflow: hidden;
        }
        
        .container {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            margin: 0 auto;
            max-width: min(600px, 100vw - 40px);
            width: 100%;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        
        .canvas-container {
            position: relative;
            margin: 20px auto;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            overflow: hidden;
            background: rgba(0,0,0,0.2);
        }
        
        canvas {
            display: block;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.1) 0%, transparent 70%);
            width: 100%;
            max-width: 560px;
            height: auto;
            aspect-ratio: 560 / 400;
        }
        
        .controls {
            margin: 20px 0;
        }
        
        button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            border: none;
            padding: 12px 20px;
            margin: 5px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .start { background: linear-gradient(45deg, #4ecdc4, #44a08d); }
        .stop { background: linear-gradient(45deg, #ff6b6b, #ee5a24); }
        .reset { background: linear-gradient(45deg, #f9ca24, #f0932b); }
        .add { background: linear-gradient(45deg, #6c5ce7, #a55eea); }
        
        .stats {
            margin-top: 15px;
            font-size: 14px;
            opacity: 0.8;
        }
        
        .ball-count {
            font-size: 18px;
            font-weight: bold;
            color: #4ecdc4;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üèÄ Bouncing Ball Physics Demo</h1>
        <p>Watch the balls bounce with realistic physics!</p>
        
        <div class="canvas-container">
            <canvas id="ballCanvas"></canvas>
        </div>
        
        <div class="controls">
            <button class="start" onclick="startAnimation()">‚ñ∂Ô∏è Start</button>
            <button class="stop" onclick="stopAnimation()">‚è∏Ô∏è Pause</button>
            <button class="reset" onclick="resetBalls()">üîÑ Reset</button>
            <button class="add" onclick="addBall()">‚ûï Add Ball</button>
        </div>
        
        <div class="stats">
            <div class="ball-count" id="ballCount">Balls: 1</div>
            <div>Click anywhere on the canvas to add a ball!</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('ballCanvas');
        const ctx = canvas.getContext('2d');
        
        // Make canvas responsive while maintaining aspect ratio
        function resizeCanvas() {
            const container = canvas.parentElement;
            const containerWidth = container.clientWidth - 4; // Account for border
            const maxWidth = 560;
            const aspectRatio = 560 / 400;
            
            let canvasWidth = Math.min(containerWidth, maxWidth);
            let canvasHeight = canvasWidth / aspectRatio;
            
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
        }
        
        // Initial resize and resize on window resize
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        let balls = [];
        let animationId = null;
        let isRunning = false;
        
        // Ball constructor
        class Ball {
            constructor(x, y, radius, color) {
                this.x = x || Math.random() * (canvas.width - 40) + 20;
                this.y = y || Math.random() * (canvas.height - 40) + 20;
                this.radius = radius || Math.random() * 15 + 10;
                this.color = color || this.getRandomColor();
                this.vx = (Math.random() - 0.5) * 8; // velocity x
                this.vy = (Math.random() - 0.5) * 8; // velocity y
                this.gravity = 0.3;
                this.friction = 0.98;
                this.bounce = 0.8;
            }
            
            getRandomColor() {
                const colors = [
                    '#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', 
                    '#f0932b', '#eb4d4b', '#6c5ce7', '#a55eea',
                    '#26de81', '#fd79a8', '#fdcb6e', '#e17055'
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            update() {
                // Apply gravity
                this.vy += this.gravity;
                
                // Update position
                this.x += this.vx;
                this.y += this.vy;
                
                // Bounce off walls
                if (this.x + this.radius > canvas.width) {
                    this.x = canvas.width - this.radius;
                    this.vx = -this.vx * this.bounce;
                }
                if (this.x - this.radius < 0) {
                    this.x = this.radius;
                    this.vx = -this.vx * this.bounce;
                }
                if (this.y + this.radius > canvas.height) {
                    this.y = canvas.height - this.radius;
                    this.vy = -this.vy * this.bounce;
                }
                if (this.y - this.radius < 0) {
                    this.y = this.radius;
                    this.vy = -this.vy * this.bounce;
                }
                
                // Apply friction
                this.vx *= this.friction;
                this.vy *= this.friction;
            }
            
            draw() {
                // Draw shadow
                ctx.save();
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(this.x + 3, this.y + 3, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                
                // Draw ball with gradient
                const gradient = ctx.createRadialGradient(
                    this.x - this.radius/3, this.y - this.radius/3, 0,
                    this.x, this.y, this.radius
                );
                gradient.addColorStop(0, this.lightenColor(this.color, 40));
                gradient.addColorStop(1, this.color);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Add highlight
                ctx.fillStyle = 'rgba(255,255,255,0.6)';
                ctx.beginPath();
                ctx.arc(this.x - this.radius/3, this.y - this.radius/3, this.radius/4, 0, Math.PI * 2);
                ctx.fill();
            }
            
            lightenColor(color, percent) {
                const num = parseInt(color.replace("#",""), 16);
                const amt = Math.round(2.55 * percent);
                const R = (num >> 16) + amt;
                const G = (num >> 8 & 0x00FF) + amt;
                const B = (num & 0x0000FF) + amt;
                return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 + 
                    (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255))
                    .toString(16).slice(1);
            }
        }
        
        // Initialize with one ball
        function init() {
            balls = [new Ball()];
            updateBallCount();
        }
        
        // Animation loop
        function animate() {
            if (!isRunning) return;
            
            // Clear canvas with fade effect
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Update and draw balls
            balls.forEach(ball => {
                ball.update();
                ball.draw();
            });
            
            animationId = requestAnimationFrame(animate);
        }
        
        // Control functions
        function startAnimation() {
            if (!isRunning) {
                isRunning = true;
                animate();
            }
        }
        
        function stopAnimation() {
            isRunning = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        }
        
        function resetBalls() {
            stopAnimation();
            balls = [new Ball()];
            updateBallCount();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        function addBall() {
            balls.push(new Ball());
            updateBallCount();
        }
        
        function updateBallCount() {
            document.getElementById('ballCount').textContent = `Balls: ${balls.length}`;
        }
        
        // Click to add ball
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            balls.push(new Ball(x, y));
            updateBallCount();
        });
        
        // Initialize and start
        init();
        startAnimation();
        
        // Auto-resize functionality for parent iframe
        function notifyParentOfResize() {
            const height = Math.max(
                document.body.scrollHeight,
                document.body.offsetHeight,
                document.documentElement.clientHeight,
                document.documentElement.scrollHeight,
                document.documentElement.offsetHeight
            );
            
            console.log('Notifying parent of height:', height);
            
            try {
                if (window.parent && window.parent !== window) {
                    window.parent.postMessage({
                        type: 'iframe-resize',
                        height: height,
                        source: window.location.href
                    }, '*');
                }
            } catch (e) {
                console.log('Failed to notify parent:', e);
            }
        }
        
        // Notify parent on various events
        window.addEventListener('load', notifyParentOfResize);
        window.addEventListener('resize', () => {
            resizeCanvas(); // Resize canvas first
            setTimeout(notifyParentOfResize, 50); // Then notify parent
        });
        document.addEventListener('DOMContentLoaded', notifyParentOfResize);
        
        // Notify after delays to catch dynamic content
        setTimeout(notifyParentOfResize, 100);
        setTimeout(notifyParentOfResize, 500);
        setTimeout(notifyParentOfResize, 1500);
        setTimeout(notifyParentOfResize, 3000);
        
        // Watch for DOM changes that might affect height
        if (window.MutationObserver) {
            const observer = new MutationObserver(() => {
                setTimeout(notifyParentOfResize, 50);
            });
            observer.observe(document.body, {
                childList: true,
                subtree: true,
                attributes: true,
                attributeFilter: ['style', 'class']
            });
        }
    </script>
</body>
</html>